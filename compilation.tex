\pagebreak

\section{Теорема о корректности компиляции}

В данном разделе приводится формулировка теоремы о
корректности компиляции, а также схема ее доказательства
и пример ее применения.

Напомним, что \Wkm была предложена в качестве модели памяти
для языков программирования (в частности, для \CPP и \LLVMIR).
Одним из важных требований, предъявляемых к таким моделям,
является корректность оптимальной схемы компиляции
в ассемблерный код современных мультипроцессоров.
Оптимальность схемы компиляции, в частности,
означает, что инструкции обращения к памяти,
аннотированные ослабленным режимом доступа ($\rlx$),
должны компилироваться в обычные инструкции обращения к
памяти целевого процессора без вставки барьеров памяти.
Корректность схемы компиляции означает, что после
компиляции множество допустимых сценариев исполнения программы
не должно увеличиваться. То есть процесс компиляции программы
не должен привносить новые сценарии исполнения программы,
и, следовательно, не должен нарушать никакие свойства программы,
гарантированные семантикой исходного языка программирования.

В контексте данной работы будем рассматривать
простой модельный язык \LLANG.
Формальное определение этого языка может быть
найдено в \cite[Рис.2]{Podkopaev-al:POPL19}.
%% \todo{Дублировать формальное определение языка?}
По сути, данный язык программирования представляет
из себя простую многопоточную регистровую машину
с разделяемой памятью.
Примитивов данного языка достаточно,
для того чтобы моделировать интересующее
нас подмножество языка \CPP и языков ассемблера мультипроцессоров.

Будем подразумевать, что и модель \Wkm
и модель \IMM заданы для языка \LLANG.
В этом случае оптимальной схемой компиляции будем считать
тождественное отображение из языка \LLANG в него же.

Таким образом, требование о корректности компиляции
из модели \Wkm в модель \IMM сводится к следующей теореме. 

\begin{theorem}
  \label{thm:main}
  Пусть $P$ это программа на языке \LLANG
  и пусть $G$ это \IMM консистентный граф сценария исполнения этой программы.
  Тогда существует структура событий $S$, соответствующая программе $P$,
  которая содержит граф $G$, то есть $S \rhd G$.
\end{theorem}

\subsection{Схема доказательства теоремы}

Для того чтобы доказать теорему о корректности компиляции
в данной работе был предложен способ построения
необходимой структуры событий с помощью метода
\emph{симуляции}~\cite{Milner:1971}.
А именно, построение структуры событий происходит
инкрементально шаг за шагом с помощью операционной семантики
%% (\todo{ссылка на раздел про оп.сем.})
путем симуляции \emph{обхода \IMM графа}
(\emph{\IMM graph traversal})~\cite[\S6,7]{Podkopaev-al:POPL19}.
Обход графа соответствует некоторому сценарию выполнения программы,
в рамках которого события исполняются согласно
сохраняемому программному порядку ($\lPPO$).

Более формально, обход графа $G$
порождает операционную семантику малого шага 
$G \vdash \TC \travstep{e} \TC'$ где $\TC$ и $\TC'$ это
\emph{конфигурации обхода}.
Конфигурация обхода, в свою очередь, это пара $\tup{C, I}$,
где $C \suq G.\lE$ это множество \emph{покрытых событий}
(\emph{covered events}), а $I \suq G.\lW$ это множество
\emph{выпущенных записей} (\emph{issued writes}).
Покрытие события соответствует выполнению
инструкции программы в обычном порядке,
в то время как выпуск события записи соответствует
спекулятивному исполнению инструкции записи вне очереди.
Событие может быть покрыто если (i) все его
$\lPO$ предшественники уже покрыты, и (ii)
это событие уже выпущено (в случае события записи)
либо оно читает из уже выпущенной записи (в случае события чтения).
Событие записи может быть выпущено если все
события записи из других потоков, от которых
зависит данное событие согласно отношению $\lPPO$, также уже выпущены. 
Эти требования могут быть выражены как следующие инварианты конфигурации обхода.

\[\def\arraystretch{1}
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
 \dom{\lPO \seq [C]} \subseteq C  &
 C \cap \lW \subseteq I             &
 \dom{\lRF \seq [C]} \subseteq I  &
 \dom{\lRFE \seq \lPPO \seq [I]} \subseteq I
\end{array}
\]

Имея операционную семантику обхода \IMM графа $G \vdash \TC \travstep{e} \TC'$
и операционную семантику построения структуры событий $S \esstepcons{e} S'$
доказательство строится на основе метода \emph{симуляции}~\cite{Milner:1971}.
А именно, определяется отношение симуляции $\simrel(P, T, G, \TC, S, X)$,
соединяющее программу $P$, подмножество идентификаторов потоков $T \suq \Tid$,
\IMM граф $G$ и текущую конфигурацию его обхода $\TC$,
текущую структуру событий $S$ и его выделенную конфигурацию $X$.
Далее доказательство строится на следующих трех леммах,
которые утверждают что 
(i) начальная конфигурация обхода и инициализирующая структура событий
связаны отношением симуляции, (ii) каждый шаг обхода графа
может быть симулирован соответствующим шагом построения структуры событий,
(iii) из конечной структуры событий, которая соответствует конечной
конфигурации обхода, может быть извлечен требуемый \IMM граф $G$.

\begin{lemma}[Начало симуляции]
  \label{lm:simstart}
  \quad\\
  Пусть $P$ это программа на языке \LLANG,
  а $G$ это соответствуюий ей \IMM консистентный граф.
  Тогда выполняется $\simrel(P, \lTID(P), G, \TCinit{G}, \ESinit(P), \lEi)$ где
  \begin{itemize}
    \item $\lTID(P)$ --- множество всех идентификаторов потоков программы~$P$;
    \item $\TCinit{G} \defeq \tup{\lEi, \lEi}$ --- это начальная конфигурация обхода,
      содержащая только инициализирующие события;
    \item $\ESinit(P)$ --- это начальная структура событий,
      также содержащая только инициализирующие события.
  \end{itemize}
\end{lemma}

\begin{lemma}[Шаг симуляции]
  \label{lm:simstep}
  \quad\\
  Если выполняется $\simrel(P, T, G, \TC, S, X)$ и ${G \vdash \TC \travstep{} \TC'}$,
  тогда существует $S'$ и $X'$, такие что выполняется
  $\simrel(P, T, G, \TC', S', X')$ и $S \esstepcons{}^* S'$.
\end{lemma}

\begin{lemma}[Окончание симуляции]
  \label{lm:simend}
  \quad\\
  Если выполняется $\simrel(P, \lTID(P), G, \TCfinal{G}, S, X)$,
  где $\TCfinal{G} \defeq \tup{G.\lE, G.\lE}$ --- это конечная
  конфигурация обхода графа, тогда граф сценария исполнения,
  порождаемый конфигурацией $X$, изоморфен $G$,
  или, другими словами, $G$ может быть извлечен из $S$:~~$S \rhd G$.
\end{lemma}

Доказательство теоремы \ref{thm:main}
проводится методом индукции по трассе обхода графа
$G \vdash \TCinit{G} \travstep{}^* \TCfinal{G}$.
Лемма \ref{lm:simstart} используется в качестве базы индукции,
лемма \ref{lm:simstep} --- это шаг индукции,
а лемма \ref{lm:simend} завершает доказательство.

В свою очередь, доказательства лемм \ref{lm:simstart} и \ref{lm:simend}
достаточно прямолинейны (найти их можно в \coq репозитории).
Основная сложность заключена в доказательстве леммы \ref{lm:simstep}.
Более детально это доказательство рассматривается~в~\cref{sec:simulation}.

%% In contrast, \cref{lemma:simstep} is much more difficult to prove.
%% As we will see, simulating a traversal step sometimes requires us
%% to construct a new branch in the event structure,
%% \ie to add multiple events (see \cref{sec:simstep}).

\subsection{Пример построения структуры событий}

Пример построения структуры событий по графу \IMM.
