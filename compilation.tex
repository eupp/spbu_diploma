\pagebreak

\section{Теорема о корректности компиляции}

В данном разделе приводится формулировка теоремы о
корректности компиляции, а также схема ее доказательства
и пример ее применения.

Напомним, что \Wkm была предложена в качестве модели памяти
для языков программирования (в частности, для \CPP и \LLVMIR).
Одним из важных требований, предъявляемых к таким моделям,
является корректность оптимальной схемы компиляции
в ассемблерный код современных мультипроцессоров.
Оптимальность схемы компиляции, в частности,
означает, что инструкции обращения к памяти,
аннотированные ослабленным режимом доступа ($\rlx$),
должны компилироваться в обычные инструкции обращения к
памяти целевого процессора без вставки барьеров памяти.
Корректность схемы компиляции означает, что после
компиляции множество допустимых сценариев исполнения программы
не должно увеличиваться. То есть процесс компиляции программы
не должен привносить новые сценарии исполнения программы,
и, следовательно, не должен нарушать никакие свойства программы,
гарантированные семантикой исходного языка программирования.

В контексте данной работы будем рассматривать
простой модельный язык \LLANG.
Формальное определение этого языка может быть
найдено в \cite[Рис.2]{Podkopaev-al:POPL19}.
%% \todo{Дублировать формальное определение языка?}
По сути, данный язык программирования представляет
из себя простую многопоточную регистровую машину
с разделяемой памятью.
Примитивов данного языка достаточно,
для того чтобы моделировать интересующее
нас подмножество языка \CPP и языков ассемблера мультипроцессоров.

Будем подразумевать, что и модель \Wkm
и модель \IMM заданы для языка \LLANG.
В этом случае оптимальной схемой компиляции будем считать
тождественное отображение из языка \LLANG в него же.

Таким образом, требование о корректности компиляции
из модели \Wkm в модель \IMM сводится к следующей теореме. 

\begin{theorem}
  \label{thm:main}
  Пусть $P$ это программа на языке \LLANG
  и пусть $G$ это \IMM консистентный граф сценария исполнения этой программы.
  Тогда существует структура событий $S$, соответствующая программе $P$,
  которая содержит граф $G$, то есть $S \rhd G$.
\end{theorem}

\subsection{Схема доказательства теоремы}

Для того чтобы доказать теорему о корректности компиляции
в данной работе был предложен способ построения
необходимой структуры событий с помощью метода
\emph{симуляции}~\cite{Milner:1971}.
А именно, построение структуры событий происходит
инкрементально шаг за шагом с помощью операционной семантики
%% (\todo{ссылка на раздел про оп.сем.})
путем симуляции \emph{обхода \IMM графа}
(\emph{\IMM graph traversal})~\cite[\S6,7]{Podkopaev-al:POPL19}.
Обход графа соответствует некоторому сценарию выполнения программы,
в рамках которого события исполняются согласно
сохраняемому программному порядку ($\lPPO$).

Более формально, обход графа $G$
порождает операционную семантику малого шага 
$G \vdash \TC \travstep{e} \TC'$ где $\TC$ и $\TC'$ это
\emph{конфигурации обхода}.
Конфигурация обхода, в свою очередь, это пара $\tup{C, I}$,
где $C \suq G.\lE$ это множество \emph{покрытых событий}
(\emph{covered events}), а $I \suq G.\lW$ это множество
\emph{выпущенных записей} (\emph{issued writes}).
Покрытие события соответствует выполнению
инструкции программы в обычном порядке,
в то время как выпуск события записи соответствует
спекулятивному исполнению инструкции записи вне очереди.
Событие может быть покрыто если (i) все его
$\lPO$ предшественники уже покрыты, и (ii)
это событие уже выпущено (в случае события записи)
либо оно читает из уже выпущенной записи (в случае события чтения).
Событие записи может быть выпущено если все
события записи из других потоков, от которых
зависит данное событие согласно отношению $\lPPO$, также уже выпущены. 
Эти требования могут быть выражены как следующие инварианты конфигурации обхода.

\[\def\arraystretch{1}
\begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
 \dom{\lPO \seq [C]} \subseteq C  &
 C \cap \lW \subseteq I             &
 \dom{\lRF \seq [C]} \subseteq I  &
 \dom{\lRFE \seq \lPPO \seq [I]} \subseteq I
\end{array}
\]

Имея операционную семантику обхода \IMM графа $G \vdash \TC \travstep{e} \TC'$
и операционную семантику построения структуры событий $S \esstepcons{e} S'$
доказательство строится на основе метода \emph{симуляции}~\cite{Milner:1971}.
А именно, определяется отношение симуляции $\simrel(P, T, G, \TC, S, X)$,
соединяющее программу $P$, подмножество идентификаторов потоков $T \suq \Tid$,
\IMM граф $G$ и текущую конфигурацию его обхода $\TC$,
текущую структуру событий $S$ и его выделенную конфигурацию $X$.
Далее доказательство строится на следующих трех леммах,
которые утверждают что 
(i) начальная конфигурация обхода и инициализирующая структура событий
связаны отношением симуляции, (ii) каждый шаг обхода графа
может быть симулирован соответствующим шагом построения структуры событий,
(iii) из конечной структуры событий, которая соответствует конечной
конфигурации обхода, может быть извлечен требуемый \IMM граф $G$.

\begin{lemma}[Начало симуляции]
  \label{lm:simstart}
  \quad\\
  Пусть $P$ это программа на языке \LLANG,
  а $G$ это соответствуюий ей \IMM консистентный граф.
  Тогда выполняется $\simrel(P, \lTID(P), G, \TCinit{G}, \ESinit(P), \lEi)$ где
  \begin{itemize}
    \item $\lTID(P)$ --- множество всех идентификаторов потоков программы~$P$;
    \item $\TCinit{G} \defeq \tup{\lEi, \lEi}$ --- это начальная конфигурация обхода,
      содержащая только инициализирующие события;
    \item $\ESinit(P)$ --- это начальная структура событий,
      также содержащая только инициализирующие события.
  \end{itemize}
\end{lemma}

\begin{lemma}[Шаг симуляции]
  \label{lm:simstep}
  \quad\\
  Если выполняется $\simrel(P, T, G, \TC, S, X)$ и ${G \vdash \TC \travstep{} \TC'}$,
  тогда существует $S'$ и $X'$, такие что выполняется
  $\simrel(P, T, G, \TC', S', X')$ и $S \esstepcons{}^* S'$.
\end{lemma}

\begin{lemma}[Окончание симуляции]
  \label{lm:simend}
  \quad\\
  Если выполняется $\simrel(P, \lTID(P), G, \TCfinal{G}, S, X)$,
  где $\TCfinal{G} \defeq \tup{G.\lE, G.\lE}$ --- это конечная
  конфигурация обхода графа, тогда граф сценария исполнения,
  порождаемый конфигурацией $X$, изоморфен $G$,
  или, другими словами, $G$ может быть извлечен из $S$:~~$S \rhd G$.
\end{lemma}

Доказательство теоремы \ref{thm:main}
проводится методом индукции по трассе обхода графа
$G \vdash \TCinit{G} \travstep{}^* \TCfinal{G}$.
Лемма \ref{lm:simstart} используется в качестве базы индукции,
лемма \ref{lm:simstep} --- это шаг индукции,
а лемма \ref{lm:simend} завершает доказательство.

В свою очередь, доказательства лемм \ref{lm:simstart} и \ref{lm:simend}
достаточно прямолинейны (найти их можно в \coq репозитории).
Основная сложность заключена в доказательстве леммы \ref{lm:simstep}.
Более детально это доказательство рассматривается~в~\cref{sec:simulation}.

%% In contrast, \cref{lemma:simstep} is much more difficult to prove.
%% As we will see, simulating a traversal step sometimes requires us
%% to construct a new branch in the event structure,
%% \ie to add multiple events (see \cref{sec:simstep}).

\subsection{Пример построения структуры событий}

Рассмотрим процесс симуляции на примере
обхода графа $\Glb$ программы $\proglb \defeq \text{\ref{ex:LB-nodep}}$,
продемонстрированного на \cref{fig:trav-ex}.
Процесс построения структуры событий,
симулирующей данный обход, совпадает с процессом,
показанным на \cref{fig:es-ex}.

\input{fig/trav-ex}

Первый шаг обхода графа выпускает событие
$\mese{1}{2}{} \wlab{}{y}{1}{}$ (\cref{fig:trav-exA}).
Чтобы симулировать этот шаг, необходимо добавить
в структуру событий ветку, содержащую событие
с аналогичной меткой $\wlab{}{y}{1}{}$.
Так как модель \Wkm требует исполнения инструкций
в программном порядке, сперва необходиом исполнить  
инструкцию $\readInst{}{a}{x}$ и добавить соответствующее событие чтения.
По правилам построения структуры событий \Wkm
для добавляемого события $\ese{1}{1}{1}$ необходимо
выбрать уже содержащиеся в структуре обосновывающее событие записи,
в данном случае таким событие является
инициализирующая запись (\cref{fig:es-ex:a}).
В общем случае, в качестве обоснования используется
некоторое ``стабильное'' событие записи (смотри \cref{def:sjf}),
то есть такое событие, которое данный поток уже ``наблюдал''
и чтение из которого не может нарушить консистентность структуры событий.
После этого, в структуру может быть добавлено событие
$\mese{1}{2}{1} \wlab{}{y}{1}$ (\cref{fig:es-ex:b}).
Далее можно показать, что для конфигурации обхода $TC_a$,
структуры событий $S_b$ и ее конфигурации $X_b$
выполняется отношение симуляции:
$\simrel(\proglb, \lTID(\proglb), \Glb, \TC_a, S_b, X_b)$.

\todo{Имена для графов?}

Далее необходимо симулировать второй шаг обхода
(\cref{fig:trav-exB}) выпускающий событие~$\wlab{}{x}{1}$.
Также как и на предыдущем шаге сперва необходимо
выполнить инструкцию $\readInst{}{b}{y}$ и добавить соответствующее
событие чтения (\cref{fig:es-ex:c}). Но в отличие от предыдущего шага
добавляемое событие~$\mese{2}{1}{} \rlab{}{y}{1}$ должно иметь
метку со значением $1$, так как от события чтения
зависит выпущенное на данном шаге событие записи.
Благодаря свойствам обхода графа, упомянутым выше,
гарантируется, что к моменту выпуска $\mese{2}{2}{} \wlab{}{x}{1}{}$
уже выпущено $\mese{1}{2}{} \wlab{}{y}{1}$.
Таким образом, к этому моменту структура событий уже должна
содержать подходящее событие запись для обоснования нового события чтения.
Действительно, в данном случае таким событием является $\ese{1}{2}{1}$.
Далее, событие $\mese{2}{2}{} \wlab{}{y}{1}{}$ может быть добавлено
в структуру событий (\cref{fig:es-ex:d}).
Для обновленной конфигураци обхода и структуры событий
будет выполняться отношение симуляции:
$\simrel(\proglb, \lTID(\proglb), \Glb, \TC_b, S_d, X_d)$.

На третьем шаге обхода покрывается событие чтения
$\mese{1}{1}{} \rlab{}{x}{1}$ (\cref{fig:trav-exC}).
В структуры событий при этом добавляется событие
$\mese{1}{1}{2} \rlab{}{x}{1}$ (\cref{fig:es-ex:e}),
которое находится в конфликте с событием $\ese{1}{1}{1}$
из альтернативной ветки исполнения потока.
Но для того, чтобы восстановить отношение симуляции,
необходимо также предъявить обновленную конфигурацию
структуры событий $X$, которая соответствовала бы
конфигурации обхода $\TC_c$.
Проблема в том, что такая конфигурация должна включать
как новое событие $\ese{1}{1}{2}$ так и
представителя для события $\mese{1}{2}{} \wlab{}{y}{1}$,
то есть событие $\ese{1}{2}{1}$ в структуре $S_e$,
Проблема заключается в том, что данная пара событий
находится в конфликте. 
Поэтому необходимо сделать ещё один шаг построения
структуры событий и добавить событие $\mese{1}{2}{2} \wlab{}{y}{1}$
(\cref{fig:es-ex:f}).
Обратим внимание, что событие записи $\ese{1}{2}{2}$ объявляется
эквивалентным событию записи $\ese{1}{2}{1}$.
Этот факт позволяет сформировать подходящую
конфигурацию $X_f$, такую что выполняется
$\simrel(\proglb, \lTID(\proglb), \Glb, \TC_c, S_f, X_f)$.

Для того, чтобы симулировать оставшиеся шаги обхода графа
(\cref{fig:trav-exD,fig:trav-exE,fig:trav-exF})
нет необходимости модифицировать структуру событий $S_f$,
так как она уже содержит все необходимые события. 
Достаточно лишь показать, что выполняются следующие утверждения:
\begin{itemize}
  \item $\simrel(\proglb, \lTID(\proglb), \Glb, \TC_d, S_f, X_f)$,
  \item $\simrel(\proglb, \lTID(\proglb), \Glb, \TC_e, S_f, X_f)$,
  \item $\simrel(\proglb, \lTID(\proglb), \Glb, \TC_f, S_f, X_f)$.
\end{itemize}
На этом процесс симуляции оканчивается.
Как можно видеть, граф, индуцированный конфигурацией $X_f$,
изоморфен начальному графу $\Glb$.
Данное наблюдение завершает доказательство.
