\pagebreak

\specialsection{Обзор}

Как уже упоминалось во введении, 
модель памяти задает семантику многопоточных программ, 
работающих с разделяемой памятью. 
Слабые модели памяти могут быть разделены на две группы:
для архитектур мультипроцессоров и для языков программирования.
Главное различие между ними заключается в том, 
что к моделям памяти языков программирования
предъявляются более строгие требования, 
в частности, они должны поддерживать широкий класс оптимизаций, 
выполняемых компиляторами. 

Архитектуры современных мультипроцессоров, как правило, 
имеют формально определенные модели: \Intel~\cite{Sewell-al:CACM10}, 
\IBMPOWER~\cite{Sarkar-al:PLDI11,Alglave-al:TOPLAS14}),
\ARM~\cite{Pulte-al:POPL18,Alglave-al:TOPLAS14})
и \RISC~\cite{Pulte-al:POPL18}.
Вышеупомянутые модели формализованы в \emph{аксиоматическом} стиле, 
широко применямом для спецификации 
слабых моделей памяти мультипроцессоров~\cite{Alglave-al:TOPLAS14}
и некоторых языков программирования~\cite{Dolan-al:PLDI18,Watt-al:PLDI2020}.

Тем не менее, модели, заданные в асиоматическом стиле, 
не способны решить проблемы, характерные 
для моделей высокопроизводительных языков программирования, 
таких как \CPP~\cite{Batty-al:ESOP15}. 
А именно, неизвестен способ аксиоматеческого задания модели,
поддерживающей оптимизации, которые потенциально могут удалять 
\emph{синтаксические зависимости} между инструкциями 
(например, распространение констант), 
и при этом запрещающей появление значений из воздуха~\cite{Batty-al:ESOP15}. 
Для решения данной проблемы было
предложено множество моделей, заданных с использованием различных подходов, 
среди них \JMM~\cite{Manson-al:POPL05}, \Prm~\cite{Kang-al:POPL17,Lee-al:PLDI20},
\Wkm~\cite{Chakraborty-Vafeiadis:POPL19}, \MRD~\cite{Paviotti-al:ESOP20} и другие.

В данной главе будет рассмотрен аксиоматический способ задания моделей
и конкретно модель \IMM, а также способ задания модели \Wkm
с помощью структур событий.

\subsection*{Аксиоматические модели памяти}

В рамках аксиоматического стиля модель памяти
определяется как множество консистентных 
\emph{графов сценариев исполнения} (\emph{execution graphs})
программы. Вершинами в этом графе являются события, 
соответствующие эффектам от выполнения инструкций программы, 
например, выполнение операции чтения $\rlab{}{x}{v}$
или записи $\wlab{}{x}{v}$ значения $v$ из/в разделяемую переменную $x$.
Ребра в графе формируют различные отношения между событиями, 
наиболее важными из них являются отношение 
\emph{программного порядка} (\emph{program order}) $\lPO$, 
которое полностью упорядочивает все события внутри одного потока,
и отношение \emph{читает-из} (\emph{reads-from}) $\lRF$, 
которое связывает событие-запись с событиями-чтениями, 
выполняющими операцию чтения из него. 
На \cref{fig:LB-nodep-execs} показаны графы сценариев исполнения, 
соответствующие программе \ref{ex:LB-nodep}.

\input{execs-ex}

Далее введем необходимые формальные определения.
Будем полагать, что $\Tid \suq \N$ обозначает множество 
\emph{идентификаторов потоков}, а поток с идентификатором $t_0 \defeq 0$
обозначает выделенный \emph{инициализирующий} поток.
Кроме того будем полагать, что $\Loc$ --- это множество 
\emph{разделяемых переменных} (или \emph{локаций}),
а $\Val$ множество возможных \emph{значений} этих переменных. 

Также операции обращения к разделяемым переменным 
могут быть аннотированы \emph{режимом доступа} (\emph{access mode}).
Будем рассматривать следующие режимы:
\emph{ослабленный} режим (\emph{relaxed}),
режимы \emph{захвата} (\emph{acquire}), \emph{освобождения} (\emph{release}),
и их комбинированный режим \emph{захвата-освобождения} (\emph{acquire-release}),
а также последовательно согласованный режим (\emph{sequentially consistent}.
Эти режимы обозначаются как $\rlx$, $\acq$, $\rel$, $\acqrel$ и $\sco$ соответственно.
Заметим, что режим $\acq$ может быть применен только к операциям чтения,
а режим $\rel$ --- только к операциям записи.
Режимы обращения упорядочены согласно строгости гарантий, 
которые они предоставляют, как показано на следующей диаграмме. 

\input{fig/modes}

Наиболее сильные гарантии предоставляют обращения, 
аннотированные режимом $\sco$ --- 
при правильном использовании они гарантируют семантику 
последовательной согласованности%
~\cite{Manson-al:POPL05,Lahav-al:PLDI17}.
Обращения с аннотацией $\rlx$ имеют слабую семантику 
и гарантируют только свойство 
\emph{когерентности} (\emph{coherence})~\cite{Alglave-al:TOPLAS14}.
Режимы $\acq$ и $\rel$ находятся в середине этого спектра
и необходимы для поддержки идиомы передачи сообщений~\cite{Lahav-al:POPL16}.
А именно, поток, который выполняет отправку сообщения, 
должен выполнить операцию освобождающей записи, 
а поток, ожидающий это сообщение, должен выполнить операцию захватывающего чтения. 

Далле, определим множество \emph{меток} (\emph{label}) операци. 
Метка $l \in \Lab$ принимает одну из следующих форм:
\begin{itemize}
  \item $\rlab{o}{x}{v}$ --- метка операции чтения значения $v$ из переменной $x$, 
    аннотированная режимом доступа $o$;
  \item $\wlab{o}{x}{v}$ --- метка операции записи значения $v$ в переменную $x$, 
    аннотированная режимом доступа $o$;
  \item $\lF^o$ --- метка операции барьера, аннотированная режимом $o$.
\end{itemize}
Будем считать, что если режим доступа $o$ опущен, 
то по-умолчанию операция аннотирована режимом $\rlx$.
Положим, что частично определенные функции $\lTYP$, $\lLOC$, $\lVAL$
принимая на вход метку $l$ возвращают её тип (то есть $\lR$, $\lW$ или $\lF$),
локацию и значение соответственно.

Наконец, представим формальное определение графов сценариев исполнения. 

\begin{definition}
  \emph{Граф сценария исполнения} (\emph{execution graph}) $G$ 
  это кортеж $\tup{\lE, \lTID, \lLAB, \lPO, \lRF, \lCO}$.
  Рассмотрим определения каждого компонента этого кортежа. 
  \begin{itemize}

    \item $\lE \suq \Event \suq \N$ --- это множество событий.

    \item $\lTID : \lE \fun \Tid$ --- это функция, присваивающая 
      каждому событию идентификатор потока.
      Будем обозначать множество событий, принадлежащих 
      инициализирующему потоку, как 
      ${\lEi \defeq \set{e \in \lE \sth \lTID(e) = t_0}}$.

    \item $\lLAB : \lE \fun \Lab$ --- это функция, присваивающая 
      каждому событию метку. Если $e \in \lE$ это событие, 
      то для краткости будем писать $\lTYP(e)$, $\lLOC(e)$, $\lVAL(e)$
      вместо $\lTYP(\lLAB(e))$, $\lLOC(\lLAB)(e))$, $\lVAL(\lLAB(e))$
      соответственно. 
      Также будем обозначать как $\lR$, $\lW$ и $\lF$ подмножества 
      событий $\lE$, которые имеют метку операции чтения, записи или барьера
      сответсвенно.

    \item $\lPO \suq \lE \times \lE$ --- это отношение 
      строгого частичного порядка на событиях, 
      именуемое \emph{программным порядком} (\emph{program order}).
      Это отношение полностью упорядочивает все события внутри одного потока
      согласно потоку управления программы. 
      Также полагается, что инициализирующие события $\lEi$ упорядочены 
      отношением $\lPO$ до всех других событий. 

    \item $\lRF \suq \lW \times \lR$ --- это отношение 
      \emph{читает-из} (\emph{reads-from}), которое соединяет 
      событие-запись с событиями-чтениями, выполняющими операцию чтения из него. 
      Связанные события записи и чтения должны иметь одну и ту же локацию и значение, 
      кроме того, для каждое событие чтения должно быть связано только с одним событием записи.
      \begin{equation*} 
        \begin{array}{rcl}
          \tup{w,r} \in \lRF 
             & \implies & \lLOC(w) = \lLOC(r) \wedge \lVAL(w) = \lVAL(r) \\
          %
          \tup{w_1,r} \in \lRF \wedge \tup{w_2,r} \in \lRF 
             & \implies & w_1 = w_2 \\
        \end{array}
      \end{equation*} 

    %%   We also define the notion of \emph{external} justification: $\lJFE \defeq \lJF \setminus \lPO$.
    %%   A read event is externally justified from a write if the write is
    %%   not $\lPO$-before the read.

    \item $\lCO \suq \lW \times \lW$ --- это отношение 
      \emph{когерентности}, строгий частичный порядок, 
      который полностью упорядочивает все операции записи 
      в одну локацию. Это отношение кодирует порядок, 
      в котором эти операции попадают в основную память
      и становятся видимы другим потокам. 
      \begin{equation*}
        \forall w_1, w_2 \in \lW \ldotp~ 
          \lLOC(w_1) = \lLOC(w_2) \implies \tup{w_1, w_2} \in \lCO \cup \lCO^{-1}
      \end{equation*}

  \end{itemize}

  Множество всех графов сценариев исполнения будем обозначать как~$\ExecG$.
\end{definition}

\begin{definition}
  \emph{Аксиоматическая модель памяти} (\emph{axiomatic memory model}) $M$ 
  задается как подмножество графов сценариев исполнения: $M \suq \ExecG$.
\end{definition}

\subsection*{Модель памяти \IMM}

Краткое введение в модель памяти \IMM.

\subsection*{Модель памяти \Wkm}

Краткое введение в модель памяти \Wkm.
Определеление структур событий \Wkm,
их консистентности, и операционной семантики
для инкрементального построения. 
