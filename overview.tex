\pagebreak

\specialsection{Обзор}

Как уже упоминалось во введении, 
модель памяти задает семантику многопоточных программ, 
работающих с разделяемой памятью. 
Слабые модели памяти могут быть разделены на две группы:
для архитектур мультипроцессоров и для языков программирования.
Главное различие между ними заключается в том, 
что к моделям памяти языков программирования
предъявляются более строгие требования, 
в частности, они должны поддерживать широкий класс оптимизаций, 
выполняемых компиляторами. 

Архитектуры современных мультипроцессоров, как правило, 
имеют формально определенные модели: \Intel~\cite{Sewell-al:CACM10}, 
\IBMPOWER~\cite{Sarkar-al:PLDI11,Alglave-al:TOPLAS14}),
\ARM~\cite{Pulte-al:POPL18,Alglave-al:TOPLAS14})
и \RISC~\cite{Pulte-al:POPL18}.
Вышеупомянутые модели формализованы в \emph{аксиоматическом} стиле, 
широко применямом для спецификации 
слабых моделей памяти мультипроцессоров~\cite{Alglave-al:TOPLAS14}
и некоторых языков программирования~\cite{Dolan-al:PLDI18,Watt-al:PLDI2020}.

Тем не менее, модели, заданные в асиоматическом стиле, 
не способны решить проблемы, характерные 
для моделей высокопроизводительных языков программирования, 
таких как \CPP~\cite{Batty-al:ESOP15}. 
А именно, неизвестен способ аксиоматеческого задания модели,
поддерживающей оптимизации, которые потенциально могут удалять 
\emph{синтаксические зависимости} между инструкциями 
(например, распространение констант), 
и при этом запрещающей появление значений из воздуха~\cite{Batty-al:ESOP15}. 
Для решения данной проблемы было
предложено множество моделей, заданных с использованием различных подходов, 
среди них \JMM~\cite{Manson-al:POPL05}, \Prm~\cite{Kang-al:POPL17,Lee-al:PLDI20},
\Wkm~\cite{Chakraborty-Vafeiadis:POPL19}, \MRD~\cite{Paviotti-al:ESOP20} и другие.

В данной главе будет рассмотрен аксиоматический способ задания моделей
и конкретно модель \IMM, а также способ задания модели \Wkm
с помощью структур событий.

\subsection*{Аксиоматические модели памяти}

В рамках аксиоматического стиля модель памяти
определяется как множество консистентных 
\emph{графов сценариев исполнения} (\emph{execution graphs})
программы. Вершинами в этом графе являются события, 
соответствующие эффектам от выполнения инструкций программы, 
например, выполнение операции чтения $\rlab{}{x}{v}$
или записи $\wlab{}{x}{v}$ значения $v$ из/в разделяемую переменную $x$.
Ребра в графе формируют различные отношения между событиями, 
наиболее важными из них являются отношение 
\emph{программного порядка} (\emph{program order}) $\lPO$, 
которое полностью упорядочивает все события внутри одного потока,
и отношение \emph{читает-из} (\emph{reads-from}) $\lRF$, 
которое связывает событие-запись с событиями-чтениями, 
выполняющими операцию чтения из него. 
На \cref{fig:LB-nodep-execs} показаны графы сценариев исполнения, 
соответствующие программе \ref{ex:LB-nodep}.

\input{fig/execs-ex}

Далее введем необходимые формальные определения.
Будем полагать, что $\Tid \suq \N$ обозначает множество 
\emph{идентификаторов потоков}, а поток с идентификатором $t_0 \defeq 0$
обозначает выделенный \emph{инициализирующий} поток.
Кроме того будем полагать, что $\Loc$ --- это множество 
\emph{разделяемых переменных} (или \emph{локаций}),
а $\Val$ множество возможных \emph{значений} этих переменных. 

Также операции обращения к разделяемым переменным 
могут быть аннотированы \emph{режимом доступа} (\emph{access mode}).
Будем рассматривать следующие режимы:
\emph{ослабленный} режим (\emph{relaxed}),
режимы \emph{захвата} (\emph{acquire}), \emph{освобождения} (\emph{release}),
и их комбинированный режим \emph{захвата-освобождения} (\emph{acquire-release}),
а также последовательно согласованный режим (\emph{sequentially consistent}.
Эти режимы обозначаются как $\rlx$, $\acq$, $\rel$, $\acqrel$ и $\sco$ соответственно.
Заметим, что режим $\acq$ может быть применен только к операциям чтения,
а режим $\rel$ --- только к операциям записи.
Режимы обращения упорядочены согласно строгости гарантий, 
которые они предоставляют, как показано на следующей диаграмме. 

\input{fig/modes}

Наиболее сильные гарантии предоставляют обращения, 
аннотированные режимом $\sco$ --- 
при правильном использовании они гарантируют семантику 
последовательной согласованности%
~\cite{Manson-al:POPL05,Lahav-al:PLDI17}.
Обращения с аннотацией $\rlx$ имеют слабую семантику 
и гарантируют только свойство 
\emph{когерентности} (\emph{coherence})~\cite{Alglave-al:TOPLAS14}.
Режимы $\acq$ и $\rel$ находятся в середине этого спектра
и необходимы для поддержки идиомы передачи сообщений~\cite{Lahav-al:POPL16}.
А именно, поток, который выполняет отправку сообщения, 
должен выполнить операцию освобождающей записи, 
а поток, ожидающий это сообщение, должен выполнить операцию захватывающего чтения. 

Далле, определим множество \emph{меток} (\emph{label}) операци. 
Метка $l \in \Lab$ принимает одну из следующих форм:
\begin{itemize}
  \item $\rlab{o}{x}{v}$ --- метка операции чтения значения $v$ из переменной $x$, 
    аннотированная режимом доступа $o$;
  \item $\wlab{o}{x}{v}$ --- метка операции записи значения $v$ в переменную $x$, 
    аннотированная режимом доступа $o$;
  \item $\lF^o$ --- метка операции барьера, аннотированная режимом $o$.
\end{itemize}
Будем считать, что если режим доступа $o$ опущен, 
то по-умолчанию операция аннотирована режимом $\rlx$.
Положим, что частично определенные функции $\lTYP$, $\lLOC$, $\lVAL$
принимая на вход метку $l$ возвращают её тип (то есть $\lR$, $\lW$ или $\lF$),
локацию и значение соответственно.

Наконец, представим формальное определение графов сценариев исполнения. 

\begin{definition}
  \label{def:exec-graph}
  \emph{Граф сценария исполнения} (\emph{execution graph}) $G$ 
  это кортеж $\tup{\lE, \lTID, \lLAB, \lPO, \lRF, \lCO}$.
  Рассмотрим определения каждого компонента этого кортежа. 
  \begin{itemize}

    \item $\lE \suq \Event \suq \N$ --- это множество событий.

    \item $\lTID : \lE \fun \Tid$ --- это функция, присваивающая 
      каждому событию идентификатор потока.
      Будем обозначать множество событий, принадлежащих 
      инициализирующему потоку, как 
      ${\lEi \defeq \set{e \in \lE \sth \lTID(e) = t_0}}$.

    \item $\lLAB : \lE \fun \Lab$ --- это функция, присваивающая 
      каждому событию метку. Если $e \in \lE$ это событие, 
      то для краткости будем писать $\lTYP(e)$, $\lLOC(e)$, $\lVAL(e)$
      вместо $\lTYP(\lLAB(e))$, $\lLOC(\lLAB)(e))$, $\lVAL(\lLAB(e))$
      соответственно. 
      Также будем обозначать как $\lR$, $\lW$ и $\lF$ подмножества 
      событий $\lE$, которые имеют метку операции чтения, записи или барьера
      сответсвенно.

    \item $\lPO \suq \lE \times \lE$ --- это отношение 
      строгого частичного порядка на событиях, 
      именуемое \emph{программным порядком} (\emph{program order}).
      Это отношение полностью упорядочивает все события внутри одного потока
      согласно потоку управления программы. 
      Также полагается, что инициализирующие события $\lEi$ упорядочены 
      отношением $\lPO$ до всех других событий.
      Также определим отношение \emph{непосредственного программного порядка}
      (\emph{immediate program order}).
      Событие $e_1$ является непосредственным $\lPO$-предшественником $e_2$ 
      если $e_1$ предшествует $e_2$ в отношении $\lPO$
      и между ними нет других события в порядке $\lPO$.
      \begin{equation*}
        \lPOimm \defeq \lPO \setminus (\lPO \seq \lPO)
      \end{equation*}

    \item $\lRF \suq [\lW] \seq \lEQLOC \cap \lEQVAL \seq [\lR]$ --- это отношение 
      \emph{читает-из} (\emph{reads-from}), которое соединяет 
      событие-запись с событиями-чтениями, выполняющими операцию чтения из него. 
      Связанные события записи и чтения должны иметь одну и ту же локацию и значение, 
      кроме того, каждое событие чтения должно быть связано только с одним событием записи.
      \begin{equation*} 
        \begin{array}{rcl}
          \tup{w_1,r} \in \lRF \wedge \tup{w_2,r} \in \lRF 
             & \implies & w_1 = w_2 \\
        \end{array}
      \end{equation*}
      Также определим внутреннею (\emph{internal}) $\lRFI$ и внешнюю (\emph{external}) $\lRFE$ версию
      отношения ``читает-из'', в зависимости от того принадлежат ли события записи и чтения
      одному и тому же потоку или нет.
      \[\def\arraystretch{1}
       \begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
         \lRFI \defeq \lRF \cap \lPO      &
         \lRFE \defeq \lRF \setminus \lPO
       \end{array}
      \]

    \item $\lCO \suq [\lW] \seq \lEQLOC \seq [\lW]$ --- это отношение 
      \emph{когерентности}, строгий частичный порядок, 
      который полностью упорядочивает все операции записи 
      в одну локацию. Это отношение кодирует порядок, 
      в котором эти операции попадают в основную память
      и становятся видимы другим потокам. 
      \begin{equation*}
        \forall w_1, w_2 \in \lW \ldotp~ 
          \lLOC(w_1) = \lLOC(w_2) \implies \tup{w_1, w_2} \in \lCO \cup \lCO^{-1}
      \end{equation*}
      По аналогии с отношением ``читает-из'' также определим
      внутреннею и внешнюю версии отношения когерентности.
      \[\def\arraystretch{1}
       \begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
         \lCOI \defeq \lCO \cap \lPO      &
         \lCOE \defeq \lCO \setminus \lPO
       \end{array}
      \]


  \end{itemize}

  Множество всех графов сценариев исполнения будем обозначать как~$\ExecG$.
\end{definition}

\begin{definition}
  \emph{Аксиоматическая модель памяти} (\emph{axiomatic memory model}) $M$ 
  задается как подмножество графов сценариев исполнения: $M \suq \ExecG$.
  Если $G \in M$ тогда будем также говорить, что граф $G$ 
  \emph{консистентен} с точки зрения модели $M$.
\end{definition}

\subsection*{Модель памяти \IMM}

В этом разделе приводится краткий разбор 
модели памяти \IMM~\cite{Podkopaev-al:POPL19},
которая предоставляет абстракцию над моделями
конкретных мультипроцессоров, в частности \Intel, \ARM, и \POWER.
Основной особенностью этих моделей, включая \IMM,
является то, что они отслеживают \emph{синтаксические зависимости}
между событиями в сценарии исполнения, а затем 
с их помощью определяют отношение \emph{сохраняемого программного порядка}
(\emph{preserved program order}) $\lPPO$, 
которое является подмножество обычного программного порядка. 
События, которые связаны сохраняемым программным порядком, 
выполняются процессором согласно этому порядку, 
а несвязанные события могут выполняться в произвольном порядке. 
 
Рассмотрим вновь программы \ref{ex:LB-nodep}, 
\ref{ex:LB-fakedep} и \ref{ex:LB-dep}.
Модель \IMM допускает сценарий исполнений 
с результатом $a = b = 1$ для программы \ref{ex:LB-nodep}, 
но не для \ref{ex:LB-fakedep} и \ref{ex:LB-dep}.
Соответствующий этому сценарию граф для 
программы \ref{ex:LB-nodep} показан на~\cref{fig:LB-nodep-ppo-exec},
а для для \ref{ex:LB-fakedep} и \ref{ex:LB-dep} на~\cref{fig:LB-dep-ppo-exec}.
Заметим, что в графе, показанном на~\cref{fig:LB-nodep-ppo-exec}, 
события в левом потоке не связаны отношением $\lPPO$.
В графе, показанном на~~\cref{fig:LB-nodep-ppo-exec}, напротив, 
события в обоих потоках связанны отношением $\lPPO$,
так как между соответствющими инструкциями 
есть \emph{зависимость по данным}.
Кроме того, объединение отношений $\lPPO$ и $\lRFE$ образует цикл. 
Именно из-за наличия этого цикла данный 
граф считается неконсистентным с точки зрения модели~\IMM.

\input{fig/lb-execs}

Далее приводится формальное определение понятия 
зависимостей и модели \IMM.

\begin{definition}
  \label{def:imm-exec-graph}
  Графом сценария исполнения в модели \IMM называется 
  обычный граф сценария исполнения (\cref{def:exec-graph}), 
  дополненный отношениями 
  \emph{зависимости по данным} (\emph{data dependency}) $\lDATA$, 
  \emph{зависимости по потоку управления} (\emph{control dependency}) $\lCTRL$, 
  и \emph{зависимости по целевому адресу} (\emph{address dependency}) $\lADDR$, 
  и \emph{зависимость по операции \CAS} (\emph{\CAS dependency}) $\lRMWDEP$.
  Объединенное отношение \emph{зависимости} (\emph{dependency}) 
  определяется следующим образом: 
  $$ \lDEPS \defeq \lDATA \cup \lCTRL \cup \lADDR \seq \lPO^? \cup \lRMWDEP. $$
  В контексте модели \IMM под графом сценария исполнения будем 
  подразумевать граф, дополненный отношениями зависимости. 
\end{definition}

%% \begin{definition}
%%   \label{def:imm-ppo}
%%   Отношение \emph{сохраняемого программного порядка} (\emph{preserved program order})
%%   определяется следующим образом:
%%   $$ \lPPO \defeq [\lR] \seq (\lDEPS \cup \lRFI)^+ \seq [W]. $$
%% \end{definition}

\begin{definition}
  \label{def:imm-aux-rel}
  В модели \IMM для графа $G$ вводятся следующием производные отношения%
  \footnote{Подробное описание приведенных здесь отношений может 
   быть найдено в~\cite{Podkopaev-al:POPL19,Moiseenko-al:ECOOP20}}.

  \begin{itemize}

    \item Отношение \emph{порядка барьеров} (\emph{barrier-order-before}):
      $$ \lBOB \defeq \lPO \seq [\lW^{\rel\squq}] \cup 
                      [\lR^{\acq\squq}] \seq \lPO \cup 
                      \lPO \seq [\lF] \cup [\lF] \seq \lPO \cup 
                      [\lW^{\rel\squq}] \seq \lPO_{\lLOC} \seq [\lW]. $$

    \item Отношение \emph{сохраняемого программного порядка} 
      (\emph{preserved program order}):
      $$ \lPPO \defeq [\lR] \seq (\lDEPS \cup \lRFI)^+ \seq [W] $$

    \item Отношение \emph{обхода} (\emph{detour}):
      $$ \lDETOUR \defeq (\lCOE \seq \lRFE) \cap \lPO. $$

    \item Отношение \emph{синхронизируется-с} (\emph{synchronizes-with}):
     $$ \lSW  \defeq [\lE^{\rel\squq}]             \seq 
                     ([\lF] \seq \lPO)^?           \seq 
                     ([\lW] \seq \lPO_{\lLOC})^?   \seq
                     (\lRF \seq \lRMW)^*           \seq 
                     \lRF \seq (\lPO \seq [\lF])^? \seq 
                     [\lE^{\acq\squq}]. 
     $$

    \item Отношение \emph{произошло-до} (\emph{happens-before}):
      $$ \lHB \defeq (\lPO \cup \lSW)^+. $$

    \item Отношение \emph{читает-до} (\emph{reads-before} или \emph{from-reads}):
      $$ \lFR \defeq \lRF^{-1} \seq \lCO. $$

    \item \emph{Расширенный порядок когерентности} 
      (\emph{extended coherence order}):
      $$ \lECO \defeq (\lCO \cup \lRF \cup \lFR)^+. $$

    \item Отношение \emph{последовательно-упорядочен-до}
      (\emph{sequentially consistent before}):
      $$ \lSCB \defeq \lPO \cup
                      \lPO\rst{\neq \lLOC} \seq \lHB \seq 
                      \lPO\rst{\neq \lLOC} \cup
                      \lHB\rst{\lLOC} \cup
                      \lCO \cup \lFR. $$

    \item Частиный порядок \emph{базовой последовательной упорядоченности}:
      $$ \lPSCB \defeq ([\lE^\sco] \cup [\lF^\sco] \seq \lHB^?) \seq 
                         \lSCB \seq 
                       ([\lE^\sco] \cup \lHB^?\seq[\lF^\sco]). 
      $$ 

    \item Частиный порядок \emph{последовательной упорядоченности барьеров}:
      $$ \lPSCF \defeq [\lF^\sco] \seq 
                       (\lHB \cup \lHB \seq \lECO \seq \lHB) \seq 
                       [\lF^\sco]. 
      $$ 

    \item Частиный порядок \emph{последовательной упорядоченности}:
      $$ \lPSC \defeq \lPSCB \cup \lPSCF. $$ 

    \item Вспомогательное \emph{ацикличное} отношение (\emph{acyclic relation}):
      $$ \lAR \defeq \lRFE \cup \lBOB \cup \lPPO \cup \lDETOUR \cup \lPSCF. $$
    
  \end{itemize}

\end{definition}

\begin{definition}
  \label{def:imm-cons}
  Граф $G$ является консистентным с точки зрения \IMM 
  если выполняются следующие условия:
  
  \begin{itemize}

    \item $\lR \suq \cod{\lRF}$;
      \labelAxiom{$\lRF$-completeness}{ax:rf-complete}

    \item $\lAR$ ациклично;
      \labelAxiom{imm-no-thin-air}{ax:imm-noota}

    \item $\lHB_{\IMM} \seq \lECO^?$ иррефлексивно;
      \labelAxiom{imm-coherent}{ax:imm-coh}

    \item $\lRMW \cap (\lFR \seq \lCO) = \emptyset$.
      \labelAxiom{rmw-atomic}{ax:imm-atom}

    \item $\lPSC$ ациклично.
      \labelAxiom{imm-sequential-consistency}{ax:imm-sc}

  \end{itemize}

\end{definition}

\subsection*{Модель памяти \Wkm}

В данном разделе приводится краткий разбор 
модели памяти \Wkm~\cite{Chakraborty-Vafeiadis:POPL19}.
Данная модель также определяет семантику программы
как множество графов сценариев исполнения. 
Но в отличие от традиционных аксиоматических моделей памяти
(вроде модели \IMM, представленной в предыдущем разделе)
в рамках которых граф считается консистентным
если он удовлетворяет некоторому предикату, 
в модели \Wkm граф считается консистентным если
он помимо этого может быть извлечен из
консистентной \emph{структуры событий} особого вида. 
Структура событий единовременно содержит несколько
сценариев исполнения программы,
некоторые из которых используются для моделирования
спекулятивного исполнения инструкций вне очереди.
Структура событий строится инкрементально
путем добавления одного нового события на каждом шаге
в соответствии с инструкциями программы.

\input{fig/es-ex}

На~\cref{fig:es-ex} показан пример построения \Wkm структуры событий,
соответствующий программе~\ref{ex:LB-nodep}.

\cref{fig:es-ex:a} показывает структуру $S_a$ полученную
за один шаг построения из начальной структуры $\Init$,
содержащей только инициализирующие события $\lEi$,
путем исполнения инструкции $\readInst{}{a}{x}$
и добавления события-чтения $\mese{1}{1}{1} \rlab{}{x}{0}$.

При добавлении каждого события-чтения  
необходимо обосновать возвращаемое значение
этого чтения, найдя соответствующее событие-запись в структуре событий.
В данном случае существует единственное событие записи
в локацию $x$ --- это инциализирующая запись.
Для отображения этой связи используется
отношение \emph{``обоснован-из''} (\emph{justified-from}) $\lJF$.
Возвращаясь к \cref{fig:es-ex:a} можно видеть,
что структура $S_a$ содержит $\lJF$ ребро
из инициализирующей структуры $\Init$ в событие $\ese{1}{1}{1}$.

Таким образом, в структуре событий \Wkm каждое событие чтения
должно быть связано отношением $\lJF$
с единственным событием записи в ту же локацию и с тем же значением.
Это требование является аналогом ограничения \ref{ax:rf-complete} в модели \IMM.
Поскольку новые события добавляются согласно программному порядку,
а также каждое событие-чтение должно быть обосновано событием записи
уже содержащимся в структуре событий, то можно видеть
что отношение $\lPO \cup \lJF$ по построению будет ацикличным.  

Следующие три шага (\cref{fig:es-ex:b,fig:es-ex:c,fig:es-ex:d})
просто добавляют новые события в структуру.
Обратим внимание, что на \cref{fig:es-ex:d} также выделено цветом
\extractedBoxText~ множество событий $X_d$,
образующий \emph{конфигурацию} структуры событий.
Данная конфигурация пораждает извлекаемый
граф сценария исполнения $G_d$,
что обозначается как $S_d \rhd G_d$,
который соответствует результату $a = 0 \wedge b = 1$. 

Следующий шаг (\cref{fig:es-ex:e}) представляет особый интерес,
так как он демонстрирует главное отличие структур событий от
графов сценариев исполнения, а именно тот факт, что
структура событий может содержать более одного сценария исполнения.
В частности, переход от $S_d$ к $S_e$ вновь исполняет первую инструкцию
левого потока программы \ref{ex:LB-nodep},
на этот раз добавляя новое событие $\mese{1}{1}{2} \rlab{}{x}{1}$,
обоснованное другим событием записи, а именно~$\ese{2}{2}{}$.
Заметим, что события $\ese{1}{1}{1}$ и $\ese{1}{1}{2}$
не могут одновременно встречаться в одном и том же
сценарии исполнения программы.
Будем говорить что такие события
находятся в отношении \emph{конфликта} (\emph{conflict}) $\lCF$.
Также отметим, что из-за наличия конфликтующих событий
отношение $\lPO$ в структуре событий не обязано
полностью упорядочивать все события внутри одного потока
(в отличие от случая графов сценариев исполнения).

Заключительный шаг построения (\cref{fig:es-ex:f})
демонстрирует ещё одну особенность модели \Wkm.
Конфликтующие события записи с одинаковой локацией и значением
могут быть объявлены \emph{эквивалентными}
с помощью отношения эквивалентности $\lEW$.
Например, в структуре $S_f$ таковыми объявлены события
$\ese{1}{2}{1}$ и $\ese{1}{2}{2}$.

Отношение $\lEW$ используется для того, чтобы
определить в модели \Wkm отношение ``читает-из'' $\lRF$.
Данное отношение связывает событие чтения со всеми
неконфликтующими событиями записи, которые эквивалентны
событию записи обосновывающему данное событие чтения.
Например, в случае структуры $S_f$,
событие $\ese{2}{1}{}$ связано отношением $\lRF$
и с событием $\ese{1}{2}{1}$, и с событием $\ese{1}{2}{2}$.

Отношение $\lRF$ в свою очередь используется для извлечения
графов сценариев исполнения из структуры событий.
Например, \cref{fig:es-ex:f} также демонстрирует конфигурацию $X_f$
и порожденный ей граф $G_f$, который соответствует результату $a = b = 1$.
В этом графе событие $\ese{2}{1}{}$ ``читает-из'' события~$\ese{1}{2}{2}$.

Далее введем формальное определение структуры событий в модели \Wkm.

\begin{definition}
  \label{def:eventstruct}
  \emph{Структура событий \Wkm} (\emph{\Wkm event structure}) $S$ 
  это кортеж $\tup{\lE, \lTID, \lLAB, \lPO, \lJF, \lEW, \lCO}$.
  Рассмотрим определения каждого компонента этого кортежа. 
  \begin{itemize}

    \item $\lE$, $\lTID$, $\lLAB$ определены по аналогии
      с графами сценариев исполнения (\cref{def:exec-graph}).

    \item $\lPO \suq \lE \times \lE$ ---
      это отношение программного порядка, определенное по аналогии
      с графами сценариев исполнения (\cref{def:exec-graph}).
      Важное отличие от случая графов сценариев исполнения
      заключается в том, что в случае структуры событий $\lPO$
      не обязано полностью упорядочивать все события внутри одного потока.
      События, принадлежащие одному потоку, но никоим образом не связанные
      отношением программного порядка, считаются \emph{конфликтующими}.
      Соответствующее отношение конфликта $\lCF$ определено следующим образом:
      \begin{equation*}
        \lCF \defeq ([\lE \setminus \lEi] \seq {=_{\lTID}} \seq [\lE \setminus \lEi])
                    \setminus (\lPO \cup \lPO^{-1})^?.
      \end{equation*}
      Кроме того, будем говорить что два события находятся в
      \emph{непосредственном конфликте} если они имеют общего $\lPO$ предка. 
      \begin{equation*}
        \lCFimm \defeq \lCF \cap (\lPOimm^{-1} \seq \lPOimm)
      \end{equation*}


    \item $\lJF \suq [\lW] \seq (\lEQLOC \cap \lEQVAL) \seq [\lR]$ --- 
      это отношение \emph{обоснован-из} (\emph{justified-from}). Оно связывает
      событие записи с событиями чтения, которые обоснованы данной записью.
      Аналогично отношению $\lRF$ в случае
      графов сценариев исполнения (\cref{def:exec-graph}),
      требуется, чтобы cвязанные события имели одну и ту же локацию и значение, 
      кроме того, каждое событие чтения должно быть связано
      только с одним событием записи.
      \begin{equation*} 
        \begin{array}{rcl}
          \tup{w_1,r} \in \lJF \wedge \tup{w_2,r} \in \lJF 
             & \implies & w_1 = w_2 \\
        \end{array}
      \end{equation*} 
      Кроме того, пологается, что чтение не может быть обосновано
      конфликтующей записью: ${\lJF \cap \lCF = \emptyset}$.
      По аналогии с отношением ``читает-из'' в случае
      графов сценариев исполнения (\cref{def:exec-graph}) также определим
      внутреннею и внешнюю версии отношения ``обоснован-из''.
      \[\def\arraystretch{1}
       \begin{array}{c@{\qquad}c@{\qquad}c@{\qquad}c}
         \lJFI \defeq \lJF \cap \lPO      &
         \lJFE \defeq \lJF \setminus \lPO
       \end{array}
      \]

    \item $\lEW \suq [\lW] \seq (\lCF \cap \lEQLOC \cap \lEQVAL)^? \seq [\lW]$ ---
      отношение \emph{эквивалентности на записях} (\emph{equal-writes}).
      Это отношение эквивалентности связывает конфликтующие
      (или идентичные) события записи с одной и той же локацией и значением.

    \item $\lCO \suq [\lW] \seq \lEQLOC \seq [\lW]$ ---
      это отношение \emph{когерентности}, определенное по аналогии с графами
      сценариев исполнения (\cref{def:exec-graph}).
      В отличие от случая графов сценариев исполнения,
      в структуре событий отношение когерентности
      полностью упорядочивает записи в одну и ту же локацию
      только с точностью до отношения $\lEW$.
      \begin{equation*}
       \forall x \in \Loc \ldotp~ \forall w_1,w_2 \in \lW_{x} \ldotp~
          \tup{w_1, w_2} \in \lEW \cup \lCO \cup \lCO^{-1}
      \end{equation*}
      Помимо этого, полагается, что отношение $\lCO$ замкнуто
      относительно отношения $\lEW$, то есть
      $\lEW \seq \lCO \seq \lEW \subseteq \lCO$.

  \end{itemize}

  Множество всех структур событий будем обозначать как~$\WkmES$.
\end{definition}

\begin{definition}
  \label{def:wkm-aux-rel}
  В модели \Wkm для структуры событий $S$ вводятся следующием производные отношения%
  \footnote{Подробное описание приведенных здесь отношений может 
   быть найдено в~\cite{Chakraborty-Vafeiadis:POPL19}}.

  \begin{itemize}

    \item Отношения $\lSW$ и $\lHB$ определены
      по аналогии с моделью \IMM (\cref{def:imm-aux-rel}),
      с той лишь разницей, что вместо отношения $\lRF$
      в их определении используется отношение $\lJF$.

    \item Отношения $\lFR$ и $\lECO$ определены
      по аналогии с моделью \IMM (\cref{def:imm-aux-rel}).

    \item Отношения $\lSCB$, $\lPSCB$, $\lPSCF$, $\lPSC$ определены
      по аналогии с моделью \IMM (\cref{def:imm-aux-rel}).

  \item Отношение \emph{расширенного конфликта} (\emph{extended conflict})
    определяется путем продолжения отношения конфликта
    вдоль отношения происходит-до.
    $$ \lECF \defeq (\lHB^{-1})^? \seq \lCF \seq \lHB^? $$
    
  \end{itemize}

\end{definition}

\todo{Определение видимых событий $\lVIS$}

\begin{definition}
\label{def:es-cons}
  Структура событий $S$ является консистентной с точки зрения
  модели \Wkm если выполняются следующие условия:
  \begin{itemize}
    \item $\dom{\lCFimm} \suq \lR$
      \labelAxiom{$\lCFimm$-read}{ax:wkm-icf-read}

    \item $\lJF \seq \lCFimm \seq \lJF^{-1} \seq \lEW$ иррефлексивно.
      \labelAxiom{$\lCFimm$-justification}{ax:wkm-icf-jf}

    \item $\lECF$ иррефлексивно.
      \labelAxiom{$\lECF$-irreflexivity}{ax:wkm-ecf-irr}

    \item $\lJF \cap \lECF = \emptyset$
      \labelAxiom{$\lJF$-non-conflict}{ax:wkm-jf-necf}

    \item $\dom{\lJFE} \suq \lVIS$
      \labelAxiom{$\lJFE$-visible}{ax:wkm-jf-vis}

    \item $\lHB \seq \lECO^?$ иррефлексивно.
      \labelAxiom{coherence}{ax:wkm-coh}
  \end{itemize}
\end{definition}

\todo{Определение конфигурации}

\todo{Определение консистентного графа \Wkm}

\todo{Определение операционной семантики \Wkm}
