\pagebreak

\specialsection{Обзор}

Как уже упоминалось во введении, 
модель памяти задает семантику многопоточных программ, 
работающих с разделяемой памятью. 
Слабые модели памяти могут быть разделены на две группы:
для архитектур мультипроцессоров и для языков программирования.
Главное различие между ними заключается в том, 
что к моделям памяти языков программирования
предъявляются более строгие требования, 
в частности, они должны поддерживать широкий класс оптимизаций, 
выполняемых компиляторами. 

Архитектуры современных мультипроцессоров, как правило, 
имеют формально определенные модели: \Intel~\cite{Sewell-al:CACM10}, 
\IBMPOWER~\cite{Sarkar-al:PLDI11,Alglave-al:TOPLAS14}),
\ARM~\cite{Pulte-al:POPL18,Alglave-al:TOPLAS14})
и \RISC~\cite{Pulte-al:POPL18}.
Вышеупомянутые модели формализованы в \emph{аксиоматическом} стиле, 
широко применямом для спецификации 
слабых моделей памяти мультипроцессоров~\cite{Alglave-al:TOPLAS14}
и некоторых языков программирования~\cite{Dolan-al:PLDI18,Watt-al:PLDI2020}.

Тем не менее, модели, заданные в асиоматическом стиле, 
не способны решить проблемы, характерные 
для моделей высокопроизводительных языков программирования, 
таких как \CPP~\cite{Batty-al:ESOP15}. 
А именно, неизвестен способ аксиоматеческого задания модели,
поддерживающей оптимизации, которые потенциально могут удалять 
\emph{синтаксические зависимости} между инструкциями 
(например, распространение констант), 
и при этом запрещающей появление значений из воздуха~\cite{Batty-al:ESOP15}. 
Для решения данной проблемы было
предложено множество моделей, заданных с использованием различных подходов, 
среди них \JMM~\cite{Manson-al:POPL05}, \Prm~\cite{Kang-al:POPL17,Lee-al:PLDI20},
\Wkm~\cite{Chakraborty-Vafeiadis:POPL19}, \MRD~\cite{Paviotti-al:ESOP20} и другие.

В данной главе будет рассмотрен аксиоматический способ задания моделей
и конкретно модель \IMM, а также способ задания модели \Wkm
с помощью структур событий.

\subsection*{Аксиоматические модели памяти}

В рамках аксиоматического стиля модель памяти
определяется как множество консистентных 
\emph{графов сценариев исполнения} (\emph{execution graphs})
программы. Вершинами в этом графе являются события, 
соответствующие эффектам от выполнения инструкций программы, 
например, выполнение операции чтения $\rlab{}{x}{v}$
или записи $\wlab{}{x}{v}$ значения $v$ из/в разделяемую переменную $x$.
Ребра в графе формируют различные отношения между событиями, 
наиболее важными из них являются отношение 
\emph{программного порядка} (\emph{program order}) $\lPO$, 
которое полностью упорядочивает все события внутри одного потока,
и отношение \emph{читает-из} (\emph{reads-from}) $\lRF$, 
которое связывает событие-запись с событиями-чтениями, 
которые выполняют операцию чтения из него. 
На \cref{fig:LB-nodep-execs} показаны графы сценариев исполнения, 
соответствующие программе \ref{ex:LB-nodep}.

\input{execs-ex}

%% Определение графов сценариев исполнения и аксиоматических моделей памяти. 

\subsection*{Модель памяти \IMM}

Краткое введение в модель памяти \IMM.

\subsection*{Модель памяти \Wkm}

Краткое введение в модель памяти \Wkm.
Определеление структур событий \Wkm,
их консистентности, и операционной семантики
для инкрементального построения. 
