\specialsection{Введение}

Современные мультипроцессоры и компиляторы 
высокоуровневых языков программирования
выполняют множество оптимизаций при исполнении
и компиляции программ соответственно с целью
повышения производительности конечного кода.
В случае многопоточных программ применение этих оптимизаций
может привести к неожиданным сценариям поведения.
Рассмотрим, например, программу \ref{ex:LB-nodep}, представленную ниже%
\footnote{В рамках данной работы в листингах будем обозначать
буквами $x, y, z$ разделяемые переменные,
а буквами $a, b, c$ --- локальные для потока переменные.}

\begin{center}
\begin{minipage}{.32\linewidth}
{\small
\begin{equation}
\inarrII{
  \readInst{}{a}{x} \rfcomment{1} \\
  \writeInst{}{y}{1} \\
}{\readInst{}{b}{y} \rfcomment{1} \\
  \writeInst{}{x}{b}  \\
}
\tag{LB-nodep}\label{ex:LB-nodep}
\end{equation}
}
\end{minipage}
%
\hfill\vline\hfill
\begin{minipage}{.32\linewidth}
{\small
\begin{equation}
\inarrII{
  \readInst{}{a}{x} \rfcomment{1} \\
  \writeInst{}{y}{1 + a * 0} \\
}{\readInst{}{b}{y} \rfcomment{1} \\
  \writeInst{}{x}{b}  \\
}
\tag{LB-fakedep}\label{ex:LB-fakedep}
\end{equation}
}
\end{minipage}
%
\hfill\vline\hfill
%
\begin{minipage}{.32\linewidth}
{\small
\begin{equation}
\inarrII{
  \readInst{}{a}{x} \nocomment{1} \\
  \writeInst{}{y}{a} \\
}{\readInst{}{b}{y} \nocomment{1} \\
  \writeInst{}{x}{b}  \\
}
\tag{LB-dep}\label{ex:LB-dep}
\end{equation}
}
\end{minipage}
\end{center}

При сборке программы, оптимизирующий компилятор
может выполнить переупорядочивание инструкций
$\readInst{}{a}{x}$ и $\writeInst{}{y}{1}$ в левом потоке, 
так как данные инструкции независимы. 
%% Кроме того, эффект от применения подобной оптимизации
%% не может наблюдаться при исполнении в однопоточной среде. 
Тем не менее, при исполнении в многопоточной среде 
эффект от применения данной оптимизации  
может наблюдаться другими потоками. 
Например, в случае \ref{ex:LB-nodep} 
это может привести к сценарию исполнения программы,
при котором обе локальные переменные $a$ и $b$
будут содержать значение~$1$. Подобные сценарии известны как 
\emph{слабые сценарии поведения} (\emph{weak behaviors}).

\emph{Моделью памяти} (\emph{memory model}) принято называть семантику 
многопоточных программ, оперирующих с разделяемой памятью%
~\cite{Moiseenko-al:PCS21}. 
\emph{Слабые модели памяти} (\emph{weak memory models}) 
призваны описать поведение многопоточных программ 
с учетом слабых сценариев поведения. 
Основной исследовательской проблемой в данной области
является формальное определение модели памяти, 
которая с одной стороны позволяла бы описывать 
эффекты от применения широкого класса оптимизаций, 
в частности, \emph{переупорядочивание независимых инструкций чтения и записи}
(\emph{load-to-store reordering}) и 
\emph{распространение констант} (\emph{constant propagation}),
а с другой стороны запрещала бы появление 
так называемых \emph{значений из воздуха} (\emph{out-of-thin-air value})%
~\cite{Moiseenko-al:PCS21,Batty-al:ESOP15}.

Данную проблему можно продемонстрировать на примере 
программ \ref{ex:LB-nodep}, \ref{ex:LB-fakedep} и \ref{ex:LB-dep}.
Желаемая модель памяти должны допускать сценарий 
поведения, при котором в результате справедливо, что $a = b = 1$,
для программ \ref{ex:LB-nodep} и \ref{ex:LB-fakedep}, 
но не для программы \ref{ex:LB-dep}.
В случае \ref{ex:LB-nodep} данный результат может быть 
обоснован переупорядочиванием независимых инструкций чтения и записи
в левом потоке. В случае \ref{ex:LB-fakedep} тот же результат 
может быть получен после применения распространения констант
и упрощения подвыражения $\writeInst{}{y}{1 + a * 0}$ до $\writeInst{}{y}{1}$,
а затем перестановки инструкций. 
В случае \ref{ex:LB-dep} сценарий поведения, 
при котором в результате получаем $a = b = 1$,
не может быть обоснован никакой комбинацией разумных оптимизаций.
Значение~$1$ в данном случае появляется \emph{``из воздуха''}.

Предъявленные выше требования, 
то есть поддержка широкого класса оптимизаций и 
запрещение значений из воздуха, являются 
критическими для моделей памяти высокопроизводительных 
языков программирования, таких как \CPP~\cite{Batty-al:POPL11}, 
\Java~\cite{Manson-al:POPL05}, или язык промежуточного представления \LLVM 
(\LLVMIR)~\cite{Chakraborty-Vafeiadis:CGO17}.
Среди нескольких кандидатов~%
\cite{Kang-al:POPL17,Paviotti-al:ESOP20,Jagadeesan-al:OOPSLA2020}, 
удовлетворяющих данным требованиям, в контексте данной работы нас будет 
интересовать модель \Wkm~\cite{Chakraborty-Vafeiadis:POPL19}, 
основанная на теории структур событий~\cite{Winskel:86}. 
К её достоинстам можно отнести декларативность и поддержку 
всего спектра возможностей модели памяти \CPP~\cite{Batty-al:POPL11}. 
Тем не менее, у данной модели существют и недостатки. 
В частности, ранее для данной модели не была доказана 
\emph{корректность оптимальной схемы компиляции} для моделей памяти 
современных мультипроцессоров, таких как 
\Intel~\cite{Sewell-al:CACM10}, \ARM~\cite{Pulte-al:POPL18} 
и \POWER~\cite{Alglave-al:TOPLAS14}. 
 
Корректность оптимальной схемы компиляции для моделей мультипроцессоров 
является ещё одним критический важным требованием, 
предъявляемым к моделям памяти высокопроизводительных языков программирования%
~\cite{Moiseenko-al:PCS21}.
Оно необходимо для того, чтобы гарантировать, 
что при компиляции инструкций обращения к разделяемым переменным 
из языка программирования в инструкции целевого процессора
не требовалось вставлять специальные инструкции --- 
\emph{барьеры памяти} (\emph{memory barriers})~\cite{McKenney:2010}, 
которые могут снижать производительность кода,
и при этом программа оставалась корректной. 

В данной работе исправляется данный недостаток. 
А именно, представлено доказательство корректности компиляции
из модели \Wkm в модели современных мультипроцессоров \Intel, \ARM и \POWER, 
формализованное с помощью системы для интерактивного 
доказательства теорем~\coq~\cite{Coq}.
Предложенное доказательтво использует \emph{промежуточную модель памяти}
(\emph{intermediate memory model, \IMM})~\cite{Podkopaev-al:POPL19}, 
предоставляющую удобную абстракцию над моделями \Intel, \ARM и \POWER, 
в качестве промежуточного звена между моделью \Wkm и моделями мультипроцессоров.

Основной сложностью доказательства является то, что модели \Wkm и \IMM
заданы в разных стилях. Модель \IMM разрешает спекулятивное 
исполнение инструкций вне очереди, но при этом 
отслеживает синтаксические зависимости между инструкциями, 
чтобы запретить появление циклов причинно-следственной связи. 
С другой стороны, модель \Wkm исполняет инструкции по порядку, 
но рассматривает единовременно несколько сценариев исполнения
объединенных в структуру событий,
некоторые из этих сценариев исполнения моделируют 
спекулятивное исполнение инструкций вне очереди. 
С помощью метода \emph{симуляции}~\cite{Milner:1971} 
демонстрируется, что построение необходимой структуры событий может 
симулировать процесс исполнения программы в модели \IMM.

\pagebreak

\specialsection{Постановка задачи}

Целью данной работы является доказательство 
теоремы о корректности компиляции из модели \Wkm 
в модели соверменных мультипроцессоров \Intel, \ARM и \POWER
с помощью модели \IMM и формализация данного доказательства в системе \coq. 
